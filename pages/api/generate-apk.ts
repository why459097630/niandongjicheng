// pages/api/generate-apk.ts
import type { NextApiRequest, NextApiResponse } from 'next'
import { Octokit } from 'octokit'

const {
  GH_OWNER,
  GH_REPO,
  GH_BRANCH = 'main',
  GH_PAT,
  WORKFLOW_ID = 'android-build-matrix.yml',
  API_SECRET,
} = process.env

function assertEnv() {
  if (!GH_OWNER || !GH_REPO || !GH_BRANCH || !GH_PAT || !WORKFLOW_ID) {
    throw new Error('Missing GH_* envs or WORKFLOW_ID')
  }
}

type FileItem = { path: string; content: string } // utf-8 文本文件

async function commitFiles(
  octokit: Octokit,
  files: FileItem[],
  message: string,
) {
  // 1) 拿 branch 最新 commit
  const { data: ref } = await octokit.rest.git.getRef({
    owner: GH_OWNER!, repo: GH_REPO!, ref: `heads/${GH_BRANCH!}`
  })
  const headSha = ref.object.sha

  const { data: headCommit } = await octokit.rest.git.getCommit({
    owner: GH_OWNER!, repo: GH_REPO!, commit_sha: headSha
  })

  // 2) 创建 blobs
  const blobs = await Promise.all(
    files.map(async f => {
      const { data } = await octokit.rest.git.createBlob({
        owner: GH_OWNER!, repo: GH_REPO!,
        content: Buffer.from(f.content, 'utf8').toString('base64'),
        encoding: 'base64',
      })
      return { path: f.path, sha: data.sha }
    })
  )

  // 3) 创建新 tree
  const { data: tree } = await octokit.rest.git.createTree({
    owner: GH_OWNER!, repo: GH_REPO!,
    base_tree: headCommit.tree.sha,
    tree: blobs.map(b => ({
      path: b.path, mode: '100644', type: 'blob', sha: b.sha
    }))
  })

  // 4) 创建 commit
  const { data: commit } = await octokit.rest.git.createCommit({
    owner: GH_OWNER!, repo: GH_REPO!,
    message,
    tree: tree.sha,
    parents: [headSha],
  })

  // 5) 更新分支指针
  await octokit.rest.git.updateRef({
    owner: GH_OWNER!, repo: GH_REPO!, ref: `heads/${GH_BRANCH!}`,
    sha: commit.sha, force: false
  })

  return commit.sha
}

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  try {
    if (req.method !== 'POST') return res.status(405).json({ ok: false, message: 'Method Not Allowed' })
    if (req.headers['x-api-secret'] !== API_SECRET) return res.status(401).json({ ok: false, message: 'unauthorized' })

    assertEnv()
    const octokit = new Octokit({ auth: GH_PAT })

    // ------- 1) 收集表单 / 生成文件 -------
    const {
      template = 'form-template',
      prompt = '',
      apk_name = 'MyApp',
      version_name = '1.0.0',
      version_code = '1',
      reason = '',
    } = (req.body || {}) as Record<string, string>

    // 这里替换成你真实生成的内容；先用最小示例保证流程跑通
    const files: FileItem[] = [
      {
        path: 'app/src/main/AndroidManifest.xml',
        content: `<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.app.generated" xmlns:android="http://schemas.android.com/apk/res/android">
  <application android:label="${apk_name}">
    <activity android:name=".MainActivity" android:exported="true">
      <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>
    </activity>
  </application>
</manifest>`
      },
      {
        path: 'app/src/main/res/values/strings.xml',
        content: `<resources><string name="app_name">${apk_name}</string></resources>`
      },
      {
        path: 'README.md',
        content: `Generated by API
template: ${template}
prompt: ${prompt}
reason: ${reason}
`
      },
    ]

    // ------- 2) 先写入安卓仓库 -------
    const commitSha = await commitFiles(
      octokit,
      files,
      `feat(api): generate ${apk_name} v${version_name} (${reason || 'no-reason'})`
    )

    // ------- 3) 再触发 CI（yml 里 inputs 必须完全一致，含 reason） -------
    await octokit.request('POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches', {
      owner: GH_OWNER!, repo: GH_REPO!,
      workflow_id: WORKFLOW_ID!,
      ref: GH_BRANCH!,
      inputs: {
        template, prompt,
        owner: GH_OWNER!, repo: GH_REPO!,
        branch: GH_BRANCH!,
        apk_name, version_name, version_code,
        reason,
      }
    })

    return res.status(200).json({ ok: true, commit: commitSha })
  } catch (e: any) {
    return res.status(500).json({ ok: false, message: e?.message || 'internal error' })
  }
}
